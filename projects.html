<!DOCTYPE html>
<html lang="en">

    <head>
    
        <meta charset="utf-8">
        <title> Code Projects </title>
        
        <link rel="stylesheet" href="style/styles.css">
        <link rel="stylesheet" type="text/css" href="resources/lightbox.css">

    </head>
    <body>
        
        <div id="container">
        
            <header>
                C:\Brandon\Software-Projects
            </header>
            
            <nav>
                <a href="index.html">About Me</a>
                &nbsp;&nbsp;&nbsp;
                <a class="nav_button" href="resources/resume.pdf" download="Brandon Martin Resume">Resume</a>
                &nbsp;&nbsp;&nbsp;
                <a href="projects.html">Software Projects</a>
                &nbsp;&nbsp;&nbsp;
                <a href="videos.html">Video Projects</a>
                &nbsp;&nbsp;&nbsp;
                <a class="nav_button" href="mailto:bsm2112@yahoo.com">Contact</a>
            </nav>

            <article>
                
                <div class="header">
                    Uno (C++)
                </div>
                <div class="project">
                    <p>
                        <a href="images/uno.png" data-lightbox="uno"><img src="images/uno.png" style="float: right; width: 400px; padding-left: 10px;"></a>
                        A text-based recreation of Mattel's card game with <span class="note">4-player online multiplayer over sockets</span>.
                        Written in C++ and built using a custom text-based game engine.
                        My goal with this project was to put my engine Cursen to the test by creating an actual game using it.
                        I also wanted to make a game with multiplayer support over sockets as well as supporting local single-player against a computer AI.
                        <br><br>
                        The toughest feature to implement for this project was the multiplayer support over sockets.
                        My strategy for distributing game state is to have <span class="note">one player act as the host</span>  who holds the authoritative game state and other players connect to that host.
                        The <span class="note">host player enforces the game's rules</span> by validating messages sent by other players.
                        Valid messages are interpreted by the host and the updated game state is broadcast to the other players.
                        <br><br>
                        I implemented my messages using a Command Pattern, where each possible message is defined as a class that can be serialized and sent over a socket.
                        The receiver deserializes the message to the proper class using header information and runs the command.
                        All changes to the game state get translated into messages that are forwarded to a command queue for distribution.
                        Depending on the game mode and network role, some messages are looped back to the sender or not sent at all and just executed locally.
                    </p>
                </div>

<!--                <div class="header">-->
<!--                    Cursen (C++)-->
<!--                </div>-->
<!--                <div class="project">-->
<!--                    <p>-->
<!--                        <img src="images/uno.png" style="float: right; width: 400px; padding-left: 10px;">-->
<!--                        A text-based user interface framework written in C++ that can be used to create games and user interfaces with text graphics-->
<!--                        <br><br>-->
<!--                        The toughest feature to implement for this project was the multiplayer support over sockets.-->
<!--                        My strategy for distributing game state is to have <span class="green">one player act as the host</span>  who holds the authoritative game state and other players connect to that host.-->
<!--                        The <span class="green">host player enforces the game's rules</span> by validating messages sent by other players.-->
<!--                        Any legal change to the game state causes the host broadcasting updates to each player.-->
<!--                        <br><br>-->
<!--                        I implemented my messages using the Command Pattern, where each possible message is defined as a class that can be serialized and sent over a socket.-->
<!--                        The receiver deserializes the message to the proper class using header information and runs the command.-->
<!--                        All changes to the game state get translated into messages that are forwarded to a command queue for distribution.-->
<!--                        Depending on the game mode and network role, some messages are looped back to the sender or not sent at all and just executed locally-->
<!--                    </p>-->
<!--                </div>-->

<!--                <div class="header">-->
<!--                    Puzzle Solver (Java)-->
<!--                </div>-->
<!--                <div class="project">-->
<!--                    <a href="images/flash_card.png" data-lightbox="flash_card"><img src="images/uno.png" style="float: right; width: 400px; padding-left: 10px;" alt="Uno"></a>-->
<!--                    <p>-->
<!--                        A text-based user interface framework written in C++ that can be used to create games and user interfaces with text graphics-->
<!--                        <br><br>-->
<!--                        The toughest feature to implement for this project was the multiplayer support over sockets.-->
<!--                        My strategy for distributing game state is to have <span class="green">one player act as the host</span>  who holds the authoritative game state and other players connect to that host.-->
<!--                        The <span class="green">host player enforces the game's rules</span> by validating messages sent by other players.-->
<!--                        Any legal change to the game state causes the host broadcasting updates to each player.-->
<!--                        <br><br>-->
<!--                        I implemented my messages using the Command Pattern, where each possible message is defined as a class that can be serialized and sent over a socket.-->
<!--                        The receiver deserializes the message to the proper class using header information and runs the command.-->
<!--                        All changes to the game state get translated into messages that are forwarded to a command queue for distribution.-->
<!--                        Depending on the game mode and network role, some messages are looped back to the sender or not sent at all and just executed locally-->
<!--                    </p>-->
<!--                </div>-->
<!--                -->
                <div class="header">
                    Flash Cards (C++)
                </div>
                <div class="project">
                    <a href="images/flash_card.png" data-lightbox="flash_card"><img src="images/flash_card.png" style="float: left; width: 350px; padding: 10px;" alt="Flashcards"></a>
                    <p>
                        Text-based Flash Cards program for creating decks of flash cards for taking notes and quizing yourself. Written in C++
                    </p>
                    <p>
                        This project was my first major program I developed using C++ as an excercise in understanding the language. I restricted my use of STL, templates, and other advanced features so I can also further understand the C language, just with the addition of classes
                    </p>
                    <p>
                        This was also my largest text-based application at the time, with multiple screens, saved data, various visual components, etc. The problems I encountered in making this program inspired me to start building Cursen, a event-based framework for developing text applications. This framework aims to streamline the production of text applications using a format similar to other GUI frameworks like WinForms
                    </p>
                </div>

                <div class="header">
                    Tetris (Python)
                </div>
                <div class="project">
                    <p>
                        <img src="images/tetris.png" style="float: right; width: 300px; height: 400px; padding-left: 10px;">
                        Recreation of the classic Tetris game with text-based graphics.
                        Created during my Junior year at DePaul University, my goals with this project was to experiment with the curses module and threading to create a text-based non turn-based game that deals with user-input concurrently with computer input.
                        Written in Python 3.
                        <br><br>
                        This project was my first attempt at making a Real-time game, as opposed to turn based games like Chess and Uno.
                        In order to do this, I needed a way of getting individual key presses and update the screen constantly.
                        I learned about the NCurses module which solved both of those problems.
                        Now I was able to receive input from the user without needing them to keep pressing enter and the screen wouldn't have to reprint itself in the terminal every update.
                        <br><br>
                        I also experimented with Python's threading module in order to make the tetris piece automatically fall when the user waits long enough. 
                    </p>
                </div>
                
            
            </article>
            
            <footer>
                Copyright 2019-2021 by Brandon Martin. All Rights Reserved.
            </footer>
        
        </div>

        <script type="text/javascript" src="resources/lightbox-plus-jquery.js"></script>
    </body>

</html>